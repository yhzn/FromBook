<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    // 实现一个“透明”的单例类，用户从这个类中创建对象的时候，可以像使用其他任何普通类一样
    var CreateDiv=(function () {
        var instance;
        var CreateDiv=function (html) {
            if(instance){
                return instance;
            }
            this.html=html;
            this.init();
            return instance=this;
        }
        CreateDiv.prototype.init=function () {
            var div=document.createElement("div");
            div.innerHTML=this.html;
            document.body.appendChild(div);
        }
        return CreateDiv
    })()

    var a1=new CreateDiv("save")

    /*
    虽然现在完成了一个透明的单例类的编写，但它同样有一些缺点。
    为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回
    真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。

    在这段代码中， CreateDiv=function (html) {} 的构造函数实际上负责了两件事情。第一是创建对象和执行初始
    化 init 方法，第二是保证只有一个对象。虽然我们目前还没有接触过“单一职责原则”的概念，
    但可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。

    假设我们某天需要利用这个类，在页面中创建千千万万的 div ，即要让这个类从单例类变成
    一个普通的可产生多个实例的类，那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象
    的那一段去掉，这种修改会给我们带来不必要的烦恼。
     */

    // 用代理实现单例模式

    var CreateDiv1=function(html){
        this.html=html;
        this.init();
    }
    CreateDiv1.prototype.init=function(){
        var div=document.createElement("div");
        div.innerHTML=this.html;
        document.body.appendChild(div);
    }

    // 引入代理类
    var ProxySingletonCreateDiv=(function(){
        var instance=null;
        return function(html){
            if(!instance){
                instance=new CreateDiv1(html)
            }
            return instance

        }
    })()

    var a2=new ProxySingletonCreateDiv("save proxy");
    var a3=new ProxySingletonCreateDiv("save g proxy");
    console.log(a2)
    console.log(a2===a3)

   /*
    通过引入代理类的方式，我们同样完成了一个单例模式的编写，跟之前不同的是，现在我们
    把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。这样一来， CreateDiv 就变成了
    一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。
    本例是缓存代理的应用之一，我们将继续了解代理带来的好处。
    */





</script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    // 这些函数中的一部分看起来和 Object 上的同名函数类似：
    // • Reflect.getOwnPropertyDescriptor(..);
    // • Reflect.defineProperty(..);
    // • Reflect.getPrototypeOf(..);
    // • Reflect.setPrototypeOf(..);
    // • Reflect.preventExtensions(..);
    // • Reflect.isExtensible(..)。

    // 区别：Object.* 相应工具会试图把它类型转换为一个对象。而这种情况下 Reflect.* 方法只会抛出一个错误

    // Reflect.ownKeys(..)
    // 返回所有“拥有”的（不是“继承”的）键的列表，就像 Object.getOwnPropertyNames(..) 和 Object.getOwnPropertySymbols(..) 返回的一样。

    // Reflect.enumerate(..)
    // 返回一个产生所有（拥有的和“继承的”）可枚举的（enumerable）非符号键集合的迭代器（参见本系列《你不知道的 JavaScript（上卷）》第二部分）。本质上说，这个键的集合和 foo..in 循环处理的那个键的集合是一样的。

    // Reflect.has(..)
    // 实质上和 in 运算符一样，用于检查某个属性是否在某个对象上或者在它的[[Prototype]] 链上。比如， Reflect.has(o, "foo") 实质上就是执行 "foo" in o 。

    // Reflect.apply(..)
    // Reflect.apply(foo,thisObj,[42,"bar"])
    // 以thisObj 作为 this 调用 foo(..)函数，传入参数 42 和 "bar"

    // Reflect.construct(..)
    // 举例来说， Reflect.construct(foo,[42,"bar"]) 实质上就是调用 new foo(42,"bar") 。

    // Reflect.get(..)
    // 举例来说， Reflect.get(o,"foo") 提取 o.foo 。

    // Reflect.set(..)
    // 举例来说， Reflect.set(o,"foo",42) 实质上就是执行 o.foo = 42 。

    // Reflect.deleteProperty(..)
    // 举例来说， Reflect.deleteProperty(o,"foo") 实质上就是执行 delete o.foo 。

</script>
</body>
</html>